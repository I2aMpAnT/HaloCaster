<!DOCTYPE html>
<html>
    <head>
        <script src="websocket_client.js"></script>
        <script src="config.js"></script>
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Overpass:wght@400;600;700&display=swap');

            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: 'Overpass', 'Highway Gothic', 'Arial', sans-serif;
                background-color: transparent;
                color: white;
            }

            #scoreboard-container {
                width: 340px;
            }

            .team-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 4px 10px;
                font-size: 18px;
                font-weight: 600;
                text-shadow: 1px 1px 0px black, -1px -1px 0px black, 1px -1px 0px black, -1px 1px 0px black;
            }

            .team-header.red {
                background-color: #C54245;
            }

            .team-header.blue {
                background-color: #4169A8;
            }

            .team-name {
                /* No text-transform - use proper case */
            }

            .team-score {
                font-weight: bold;
            }

            .team-gap {
                height: 6px;
            }

            .players-section {
                display: flex;
                flex-direction: column;
            }

            .player-row {
                display: flex;
                align-items: center;
                padding: 2px 6px;
                font-size: 14px;
                text-shadow: 1px 1px 0px black, -1px -1px 0px black, 1px -1px 0px black, -1px 1px 0px black;
            }

            .player-row.red {
                background-color: #C54245;
            }

            .player-row.blue {
                background-color: #4169A8;
            }

            .player-emblem {
                width: 22px;
                height: 22px;
                margin-right: 4px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .player-emblem img {
                max-width: 22px;
                max-height: 22px;
            }

            .player-emblem iframe {
                width: 22px;
                height: 22px;
                border: none;
                pointer-events: none;
                transform: scale(0.0859375); /* 22/256 = 0.0859375 */
                transform-origin: top left;
                width: 256px;
                height: 256px;
            }

            .emblem-iframe-container {
                width: 22px;
                height: 22px;
                overflow: hidden;
            }

            .dead-x {
                color: #FF0000;
                font-size: 18px;
                font-weight: bold;
                line-height: 1;
                width: 22px;
                height: 22px;
                display: flex;
                align-items: center;
                justify-content: center;
                text-align: center;
            }

            .player-name {
                flex: 1;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .player-weapon {
                width: 22px;
                height: 16px;
                margin-left: 4px;
                margin-right: 4px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .player-weapon img {
                max-width: 22px;
                max-height: 16px;
                filter: brightness(0) invert(1);
            }

            .player-stats {
                display: flex;
                gap: 2px;
                font-size: 13px;
            }

            .stat-label {
                opacity: 0.7;
            }

            .stat-value {
                min-width: 12px;
                text-align: right;
            }

            .objective-icon {
                width: 16px;
                height: 16px;
                margin-right: 2px;
                filter: brightness(0) invert(1);
                vertical-align: middle;
            }

            .objective-stat {
                display: flex;
                align-items: center;
                margin-right: 4px;
            }

            #connection-status {
                display: none;
            }
        </style>
    </head>
    <body>
        <div id="scoreboard-container">
            <!-- Red Team Header -->
            <div class="team-header red">
                <span class="team-name" id="red-team-name">Red Team</span>
                <span class="team-score" id="red-team-score">0</span>
            </div>
            <!-- Blue Team Header -->
            <div class="team-header blue">
                <span class="team-name" id="blue-team-name">Blue Team</span>
                <span class="team-score" id="blue-team-score">0</span>
            </div>
            <!-- Gap -->
            <div class="team-gap"></div>
            <!-- Players Section -->
            <div id="players-section" class="players-section">
                <!-- Dynamic player rows -->
            </div>
        </div>
        <div id="connection-status">Connecting...</div>

        <script>
            const client = new websocket_client();
            let updateInterval;
            let redTeamData = null;
            let blueTeamData = null;
            // Track player states to avoid unnecessary DOM updates
            let playerRowCache = new Map();

            async function init() {
                const wsUrl = `ws://${window.config.host}:${window.config.port}`;

                try {
                    await client.connect(wsUrl);
                    document.getElementById('connection-status').textContent = 'Connected';

                    client.add_message_recieved_callback('get_team_scoreboard', handleTeamScoreboard);
                    client.add_message_recieved_callback('close', handleDisconnect);

                    // Request both teams
                    requestBothTeams();

                    // Poll every 500ms for responsive time-based scores
                    updateInterval = setInterval(() => {
                        requestBothTeams();
                    }, 500);

                } catch (error) {
                    document.getElementById('connection-status').textContent = 'Connection failed';
                    console.error('Failed to connect:', error);
                    setTimeout(init, 3000);
                }
            }

            function requestBothTeams() {
                client.request_team_scoreboard(0); // Red
                client.request_team_scoreboard(1); // Blue
            }

            function handleDisconnect() {
                document.getElementById('connection-status').textContent = 'Disconnected - Reconnecting...';
                if (updateInterval) clearInterval(updateInterval);
                setTimeout(init, 3000);
            }

            function handleTeamScoreboard(response) {
                const teamIndex = parseInt(response.team_index);

                if (teamIndex === 0) {
                    redTeamData = response;
                } else if (teamIndex === 1) {
                    blueTeamData = response;
                }

                renderScoreboard();
            }

            // Check if game type uses time-based scoring
            function isTimeBasedGameType(gameType) {
                if (!gameType) return false;
                const gt = gameType.toLowerCase();
                return gt.includes('oddball') || gt.includes('ball') ||
                       gt.includes('king') || gt.includes('koth') ||
                       gt.includes('juggernaut');
            }

            function renderScoreboard() {
                // Determine if scores should be displayed as time
                const gameType = redTeamData?.game_type || blueTeamData?.game_type;
                const useTimeFormat = isTimeBasedGameType(gameType);

                // Update team headers
                if (redTeamData) {
                    document.getElementById('red-team-name').textContent = redTeamData.team_name || 'Red Team';
                    const redScore = redTeamData.team_score || 0;
                    document.getElementById('red-team-score').textContent = useTimeFormat ? formatTime(redScore) : redScore;
                }
                if (blueTeamData) {
                    document.getElementById('blue-team-name').textContent = blueTeamData.team_name || 'Blue Team';
                    const blueScore = blueTeamData.team_score || 0;
                    document.getElementById('blue-team-score').textContent = useTimeFormat ? formatTime(blueScore) : blueScore;
                }

                const playersSection = document.getElementById('players-section');

                // Collect all current players
                const allPlayers = [];
                if (redTeamData && redTeamData.players) {
                    redTeamData.players.forEach((player, idx) => {
                        allPlayers.push({ player, teamColor: 'red', gameType: redTeamData.game_type, id: `red-${idx}` });
                    });
                }
                if (blueTeamData && blueTeamData.players) {
                    blueTeamData.players.forEach((player, idx) => {
                        allPlayers.push({ player, teamColor: 'blue', gameType: blueTeamData.game_type, id: `blue-${idx}` });
                    });
                }

                // Track which rows we've seen this update
                const seenIds = new Set();

                allPlayers.forEach(({ player, teamColor, gameType, id }) => {
                    seenIds.add(id);

                    let rowEl = document.getElementById(`player-row-${id}`);
                    const cached = playerRowCache.get(id);

                    // Check if we need to rebuild the row (player changed, dead status changed, or emblem changed)
                    const needsRebuild = !rowEl ||
                        !cached ||
                        cached.isDead !== player.is_dead ||
                        cached.emblemUrl !== player.emblem_url ||
                        cached.name !== player.name;

                    if (needsRebuild) {
                        // Create or replace the row
                        const newRow = createPlayerRowElement(player, teamColor, gameType, id);
                        if (rowEl) {
                            rowEl.replaceWith(newRow);
                        } else {
                            playersSection.appendChild(newRow);
                        }
                        rowEl = newRow;

                        // Update cache
                        playerRowCache.set(id, {
                            isDead: player.is_dead,
                            emblemUrl: player.emblem_url,
                            name: player.name
                        });
                    } else {
                        // Just update dynamic content (stats, weapon) without touching iframe
                        updatePlayerRowStats(rowEl, player, gameType);
                    }
                });

                // Remove rows for players no longer present
                const existingRows = playersSection.querySelectorAll('.player-row');
                existingRows.forEach(row => {
                    const rowId = row.id.replace('player-row-', '');
                    if (!seenIds.has(rowId)) {
                        row.remove();
                        playerRowCache.delete(rowId);
                    }
                });
            }

            // Map weapon names to icon filenames
            function getWeaponIconPath(weaponName) {
                if (!weaponName || weaponName === 'None') return 'Weapons/None.png';
                const cleanName = weaponName.replace(/\s+/g, '');
                return `Weapons/${cleanName}.png`;
            }

            // Format seconds to M:SS
            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }

            // Get objective score based on game type
            function getObjectiveScore(player, gameType) {
                if (!gameType) return null;
                const gt = gameType.toLowerCase();

                if (gt.includes('ctf') || gt.includes('capture')) {
                    return { value: player.ctf_scores || 0, isTime: false };
                } else if (gt.includes('assault') || gt.includes('bomb')) {
                    return { value: player.assault_score || 0, isTime: false };
                } else if (gt.includes('oddball') || gt.includes('ball')) {
                    return { value: player.oddball_score || 0, isTime: true };
                } else if (gt.includes('king') || gt.includes('koth')) {
                    return { value: player.koth_time || 0, isTime: true };
                } else if (gt.includes('territories') || gt.includes('territory')) {
                    return { value: player.territories_taken || 0, isTime: false };
                } else if (gt.includes('juggernaut')) {
                    return { value: player.juggernaut_time || 0, isTime: true };
                }
                return null;
            }

            function createPlayerRowElement(player, teamColor, gameType, id) {
                const row = document.createElement('div');
                row.className = `player-row ${teamColor}`;
                row.id = `player-row-${id}`;

                // Emblem container
                const emblemDiv = document.createElement('div');
                emblemDiv.className = 'player-emblem';

                if (player.is_dead) {
                    emblemDiv.innerHTML = '<span class="dead-x">X</span>';
                } else if (player.emblem_url) {
                    emblemDiv.innerHTML = `<div class="emblem-iframe-container"><iframe src="${player.emblem_url}" scrolling="no"></iframe></div>`;
                } else {
                    emblemDiv.innerHTML = '<span style="width:22px;height:22px;background:#444;border-radius:2px;display:inline-block;"></span>';
                }
                row.appendChild(emblemDiv);

                // Weapon
                const weaponDiv = document.createElement('div');
                weaponDiv.className = 'player-weapon';
                const weaponPath = getWeaponIconPath(player.current_weapon);
                weaponDiv.innerHTML = `<img src="${weaponPath}" alt="${player.current_weapon || 'None'}">`;
                row.appendChild(weaponDiv);

                // Name
                const nameSpan = document.createElement('span');
                nameSpan.className = 'player-name';
                nameSpan.textContent = player.name || 'Unknown';
                row.appendChild(nameSpan);

                // Stats
                const statsDiv = document.createElement('div');
                statsDiv.className = 'player-stats';
                updateStatsDiv(statsDiv, player, gameType);
                row.appendChild(statsDiv);

                return row;
            }

            function updatePlayerRowStats(rowEl, player, gameType) {
                // Update weapon
                const weaponDiv = rowEl.querySelector('.player-weapon img');
                if (weaponDiv) {
                    const newPath = getWeaponIconPath(player.current_weapon);
                    if (weaponDiv.src !== newPath) {
                        weaponDiv.src = newPath;
                        weaponDiv.alt = player.current_weapon || 'None';
                    }
                }

                // Update stats
                const statsDiv = rowEl.querySelector('.player-stats');
                if (statsDiv) {
                    updateStatsDiv(statsDiv, player, gameType);
                }
            }

            function updateStatsDiv(statsDiv, player, gameType) {
                const isSlayer = !gameType || gameType.toLowerCase().includes('slayer');
                const objective = getObjectiveScore(player, gameType);

                let html = '';
                if (!isSlayer && objective) {
                    const displayValue = objective.isTime ? formatTime(objective.value) : objective.value;
                    html += `<span class="stat-label">Score:</span><span class="stat-value">${displayValue}</span>`;
                }
                html += `
                    <span class="stat-label">K</span>
                    <span class="stat-value">${player.kills || 0}</span>
                    <span class="stat-label">D</span>
                    <span class="stat-value">${player.deaths || 0}</span>
                    <span class="stat-label">A</span>
                    <span class="stat-value">${player.assists || 0}</span>
                `;
                statsDiv.innerHTML = html;
            }

            // Start
            init();
        </script>
    </body>
</html>
