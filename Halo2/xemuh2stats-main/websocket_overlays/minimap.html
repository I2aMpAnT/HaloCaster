<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Halo 2 Player Location Minimap</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #1a1a2e;
            color: white;
        }

        h1 {
            color: #eee;
        }

        label {
            margin-right: 5px;
        }

        input[type="text"] {
            padding: 5px;
            margin: 5px;
            border-radius: 3px;
            border: 1px solid #444;
            background-color: #2a2a4e;
            color: white;
        }

        button {
            padding: 8px 16px;
            margin: 5px;
            border-radius: 5px;
            border: none;
            background-color: #4a4a8e;
            color: white;
            cursor: pointer;
        }

        button:hover {
            background-color: #6a6aae;
        }

        #connectionStatus {
            color: #aaa;
        }

        #minimap {
            border: 2px solid #444;
            margin-top: 20px;
            background-color: #0a0a1e;
            cursor: grab;
        }

        #minimap:active {
            cursor: grabbing;
        }

        .controls {
            margin-top: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .zoom-controls button {
            width: 40px;
            height: 40px;
            font-size: 20px;
            padding: 0;
        }

        #zoomLevel {
            min-width: 60px;
            text-align: center;
        }

        .info {
            margin-top: 10px;
            font-size: 12px;
            color: #888;
        }
    </style>
</head>
<body>
    <h1>Halo 2 Player Location Minimap</h1>

    <!-- WebSocket connection inputs and controls -->
    <label for="serverIp">Server IP:</label>
    <input type="text" id="serverIp" value="localhost" placeholder="e.g., localhost">

    <label for="serverPort">Server Port:</label>
    <input type="text" id="serverPort" value="3333" placeholder="e.g., 3333">

    <button id="connectBtn">Connect</button>
    <p id="connectionStatus">Not connected</p>

    <!-- Zoom Controls -->
    <div class="controls">
        <div class="zoom-controls">
            <button id="zoomOut">-</button>
            <span id="zoomLevel">100%</span>
            <button id="zoomIn">+</button>
        </div>
        <button id="resetView">Reset View</button>
    </div>

    <p class="info">Drag to pan, scroll to zoom, click Reset View to restore default position</p>

    <!-- Minimap Canvas -->
    <canvas id="minimap" width="500" height="500"></canvas>

    <script>
        // Canvas minimap variables
        const canvas = document.getElementById('minimap');
        const ctx = canvas.getContext('2d');
        const canvasSize = 500;
        const halfCanvasSize = canvasSize / 2;

        // Zoom variables
        let zoomLevel = 1.0; // 1.0 = 100%
        const minZoom = 0.25;
        const maxZoom = 4.0;
        const zoomStep = 0.25;
        const baseWorldSize = 50; // Base range of [-25, 25]

        // Pan variables
        let panX = 0; // World coordinate offset
        let panY = 0;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        function getWorldSize() {
            return baseWorldSize / zoomLevel;
        }

        function getScale() {
            return canvasSize / getWorldSize();
        }

        // Define Z-value range (height) for scaling circles
        const zMin = -20;
        const zMax = 10;
        const circleMinSize = 2;
        const circleMaxSize = 10;

        let playersData = {};
        let lastUpdateTime = 0;

        // WebSocket Client
        class WebSocketClient {
            constructor() {
                this.socket = null;
                this.isConnected = false;
                this.eventHandlers = {};
            }

            connect(wsUrl) {
                return new Promise((resolve, reject) => {
                    this.socket = new WebSocket(wsUrl);

                    this.socket.addEventListener('open', (event) => {
                        console.log('Connected to WebSocket server');
                        this.isConnected = true;
                        resolve();
                    });

                    this.socket.addEventListener('message', (event) => {
                        this.handleMessage(event.data);
                    });

                    this.socket.addEventListener('error', (event) => {
                        console.error('WebSocket error:', event);
                        reject(event);
                    });

                    this.socket.addEventListener('close', (event) => {
                        console.log('WebSocket connection closed:', event);
                        this.isConnected = false;
                        if (this.eventHandlers['close']) {
                            this.eventHandlers['close'](event);
                        }
                    });
                });
            }

            sendMessage(message) {
                if (this.isConnected && this.socket.readyState === WebSocket.OPEN) {
                    this.socket.send(JSON.stringify(message));
                } else {
                    console.warn('WebSocket is not connected.');
                }
            }

            handleMessage(data) {
                const responseWrapper = JSON.parse(data);
                const response = responseWrapper.response;

                if (responseWrapper.message_type === 'get_players') {
                    // Replace entire playersData to clear old/disconnected players
                    playersData = response;
                    lastUpdateTime = Date.now();
                    drawMinimap();
                }
            }

            on(eventType, handler) {
                this.eventHandlers[eventType] = handler;
            }
        }

        // Initialize WebSocket client
        let wsClient = new WebSocketClient();

        // Connection setup
        document.getElementById('connectBtn').addEventListener('click', function () {
            const serverIp = document.getElementById('serverIp').value.trim();
            const serverPort = document.getElementById('serverPort').value.trim();

            if (!serverIp || !serverPort) {
                alert('Please enter both server IP and port.');
                return;
            }

            const wsUrl = `ws://${serverIp}:${serverPort}`;
            wsClient.connect(wsUrl).then(() => {
                document.getElementById('connectionStatus').textContent = 'Connected to ' + wsUrl;

                setInterval(() => {
                    const message = { message_type: 'get_players', arguments: { type: 'location' } };
                    wsClient.sendMessage(message);
                }, 200);
            }).catch((error) => {
                console.error('Connection error:', error);
                document.getElementById('connectionStatus').textContent = 'Connection error';
            });
        });

        // Zoom controls
        document.getElementById('zoomIn').addEventListener('click', function() {
            if (zoomLevel < maxZoom) {
                zoomLevel = Math.min(zoomLevel + zoomStep, maxZoom);
                updateZoomDisplay();
                drawMinimap();
            }
        });

        document.getElementById('zoomOut').addEventListener('click', function() {
            if (zoomLevel > minZoom) {
                zoomLevel = Math.max(zoomLevel - zoomStep, minZoom);
                updateZoomDisplay();
                drawMinimap();
            }
        });

        document.getElementById('resetView').addEventListener('click', function() {
            zoomLevel = 1.0;
            panX = 0;
            panY = 0;
            updateZoomDisplay();
            drawMinimap();
        });

        // Mouse wheel zoom
        canvas.addEventListener('wheel', function(e) {
            e.preventDefault();
            if (e.deltaY < 0) {
                // Zoom in
                if (zoomLevel < maxZoom) {
                    zoomLevel = Math.min(zoomLevel + zoomStep, maxZoom);
                }
            } else {
                // Zoom out
                if (zoomLevel > minZoom) {
                    zoomLevel = Math.max(zoomLevel - zoomStep, minZoom);
                }
            }
            updateZoomDisplay();
            drawMinimap();
        });

        // Drag/pan functionality
        canvas.addEventListener('mousedown', function(e) {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            canvas.style.cursor = 'grabbing';
        });

        canvas.addEventListener('mousemove', function(e) {
            if (isDragging) {
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;

                // Convert pixel movement to world coordinates
                const scale = getScale();
                panX += deltaX / scale;
                panY -= deltaY / scale; // Invert Y for world coordinates

                lastMouseX = e.clientX;
                lastMouseY = e.clientY;

                drawMinimap();
            }
        });

        canvas.addEventListener('mouseup', function(e) {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        canvas.addEventListener('mouseleave', function(e) {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        function updateZoomDisplay() {
            document.getElementById('zoomLevel').textContent = Math.round(zoomLevel * 100) + '%';
        }

        // Team color mapping
        const teamColors = {
            '0': '#FF4444',  // Red
            '1': '#4444FF',  // Blue
            '2': '#FFFF44',  // Yellow
            '3': '#44FF44',  // Green
            '4': '#AA44AA',  // Purple
            '5': '#FF8844',  // Orange
            '6': '#8B4513',  // Brown
            '7': '#FF69B4',  // Pink
            '8': '#AAAAAA',  // Neutral
            '_game_team_red': '#FF4444',
            '_game_team_blue': '#4444FF',
            '_game_team_yellow': '#FFFF44',
            '_game_team_green': '#44FF44',
            '_game_team_purple': '#AA44AA',
            '_game_team_orange': '#FF8844',
            '_game_team_brown': '#8B4513',
            '_game_team_pink': '#FF69B4',
            '_game_team_neutral': '#AAAAAA'
        };

        // Height difference threshold for showing arrows
        // Player model is ~2 units tall, 150% = 3 units difference triggers arrow
        const heightThreshold = 3.0;
        const symbolSize = 10;
        const facingConeLength = 25; // Length of facing direction cone
        const facingConeAngle = Math.PI / 6; // 30 degree cone (15 degrees each side)

        // Function to draw the minimap
        function drawMinimap() {
            const scale = getScale();

            // Clear the canvas with dark background
            ctx.fillStyle = '#0a0a1e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid lines
            ctx.strokeStyle = '#1a1a3e';
            ctx.lineWidth = 1;
            const gridSpacing = 10 * scale; // Grid every 10 world units

            // Offset grid based on pan
            const gridOffsetX = (panX * scale) % gridSpacing;
            const gridOffsetY = (panY * scale) % gridSpacing;

            for (let i = -canvasSize; i <= canvasSize * 2; i += gridSpacing) {
                ctx.beginPath();
                ctx.moveTo(i + gridOffsetX, 0);
                ctx.lineTo(i + gridOffsetX, canvasSize);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i - gridOffsetY);
                ctx.lineTo(canvasSize, i - gridOffsetY);
                ctx.stroke();
            }

            // Draw center crosshair (at world origin, accounting for pan)
            const originX = halfCanvasSize + panX * scale;
            const originY = halfCanvasSize - panY * scale;
            ctx.strokeStyle = '#333366';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(originX, 0);
            ctx.lineTo(originX, canvasSize);
            ctx.moveTo(0, originY);
            ctx.lineTo(canvasSize, originY);
            ctx.stroke();

            // Check if data is stale (no update in 2 seconds)
            const isStale = Date.now() - lastUpdateTime > 2000;

            if (isStale && Object.keys(playersData).length > 0) {
                // Draw stale indicator
                ctx.fillStyle = '#FF0000';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('NO DATA', 10, 20);
            }

            // Get first player's Z as reference (or use 0)
            let referenceZ = 0;
            const playerNames = Object.keys(playersData);
            if (playerNames.length > 0) {
                referenceZ = playersData[playerNames[0]].Z || 0;
            }

            // Loop through each player in playersData
            for (const playerName in playersData) {
                const player = playersData[playerName];
                const x = player.X;
                const y = player.Y;
                const z = player.Z;
                const facing = player.facing || 0;
                const team = player.team || '8'; // Default to neutral

                // Convert world coordinates to canvas coordinates (with pan offset)
                const canvasX = halfCanvasSize + (x + panX) * scale;
                const canvasY = halfCanvasSize - (y + panY) * scale;

                // Skip if off canvas
                if (canvasX < -50 || canvasX > canvasSize + 50 || canvasY < -50 || canvasY > canvasSize + 50) {
                    continue;
                }

                // Get team color
                const color = teamColors[team] || '#FFFFFF';

                // Determine height difference from reference player
                const heightDiff = z - referenceZ;

                // Draw facing direction cone FIRST (so it appears behind the symbol)
                // This is a pie/wedge shape showing field of view
                ctx.fillStyle = color + '40'; // 25% opacity
                ctx.strokeStyle = color + '80'; // 50% opacity
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(canvasX, canvasY);
                // Arc from facing - coneAngle to facing + coneAngle
                // Note: canvas Y is inverted, so we negate the facing angle for correct direction
                const canvasFacing = -facing; // Invert for canvas coordinates
                ctx.arc(canvasX, canvasY, facingConeLength, canvasFacing - facingConeAngle, canvasFacing + facingConeAngle);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Draw the player symbol
                ctx.fillStyle = color;
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;

                if (heightDiff > heightThreshold) {
                    // Player is higher - draw up arrow (triangle pointing up)
                    ctx.beginPath();
                    ctx.moveTo(canvasX, canvasY - symbolSize);
                    ctx.lineTo(canvasX + symbolSize, canvasY + symbolSize);
                    ctx.lineTo(canvasX - symbolSize, canvasY + symbolSize);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else if (heightDiff < -heightThreshold) {
                    // Player is lower - draw down arrow (triangle pointing down)
                    ctx.beginPath();
                    ctx.moveTo(canvasX, canvasY + symbolSize);
                    ctx.lineTo(canvasX + symbolSize, canvasY - symbolSize);
                    ctx.lineTo(canvasX - symbolSize, canvasY - symbolSize);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else {
                    // Player is at similar height - draw filled circle
                    ctx.beginPath();
                    ctx.arc(canvasX, canvasY, symbolSize, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }

                // Draw a small line in the exact facing direction from center
                const lineEndX = canvasX + Math.cos(-facing) * (symbolSize + 8);
                const lineEndY = canvasY + Math.sin(-facing) * (symbolSize + 8);
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(canvasX, canvasY);
                ctx.lineTo(lineEndX, lineEndY);
                ctx.stroke();
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(canvasX, canvasY);
                ctx.lineTo(lineEndX, lineEndY);
                ctx.stroke();

                // Draw player name above the symbol
                ctx.fillStyle = '#FFFFFF';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.strokeText(playerName, canvasX, canvasY - symbolSize - 4);
                ctx.fillText(playerName, canvasX, canvasY - symbolSize - 4);
            }
        }

        // Initial draw
        drawMinimap();
    </script>
</body>
</html>
