<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Halo 2 Player Location Minimap</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }

        #minimap {
            border: 1px solid black;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <h1>Halo 2 Player Location Minimap</h1>

    <!-- WebSocket connection inputs and controls -->
    <label for="serverIp">Server IP:</label>
    <input type="text" id="serverIp" placeholder="e.g., localhost"><br>
    
    <label for="serverPort">Server Port:</label>
    <input type="text" id="serverPort" placeholder="e.g., 8080"><br>
    
    <button id="connectBtn">Connect</button>
    <p id="connectionStatus">Not connected</p>

    <!-- Minimap Canvas -->
    <canvas id="minimap" width="500" height="500"></canvas>

    <script>
        // Canvas minimap variables
        const canvas = document.getElementById('minimap');
        const ctx = canvas.getContext('2d');
        const canvasSize = 500;
        const halfCanvasSize = canvasSize / 2;
        const worldSize = 50; // Range of [-25, 25]
        const scale = canvasSize / worldSize; // Scaling factor for world units to canvas

        // Define Z-value range (height) for scaling circles
        const zMin = -20; // Lowest Z value (most negative)
        const zMax = 10;   // Highest Z value (closest to zero)
        const circleMinSize = 2;  // Minimum circle size
        const circleMaxSize = 10; // Maximum circle size

        let playersData = {};

        // WebSocket Client
        class WebSocketClient {
            constructor() {
                this.socket = null;
                this.isConnected = false;
                this.eventHandlers = {};
            }

            connect(wsUrl) {
                return new Promise((resolve, reject) => {
                    this.socket = new WebSocket(wsUrl);

                    this.socket.addEventListener('open', (event) => {
                        console.log('Connected to WebSocket server');
                        this.isConnected = true;
                        resolve();
                    });

                    this.socket.addEventListener('message', (event) => {
                        this.handleMessage(event.data);
                    });

                    this.socket.addEventListener('error', (event) => {
                        console.error('WebSocket error:', event);
                        reject(event);
                    });

                    this.socket.addEventListener('close', (event) => {
                        console.log('WebSocket connection closed:', event);
                        this.isConnected = false;
                        if (this.eventHandlers['close']) {
                            this.eventHandlers['close'](event);
                        }
                    });
                });
            }

            sendMessage(message) {
                if (this.isConnected && this.socket.readyState === WebSocket.OPEN) {
                    this.socket.send(JSON.stringify(message));
                } else {
                    console.warn('WebSocket is not connected.');
                }
            }

            handleMessage(data) {
                const responseWrapper = JSON.parse(data);
                const response = responseWrapper.response;

                // Handle player location data if the message type is get_players
                if (responseWrapper.message_type === 'get_players') {
                    playersData = response;
                    drawMinimap();
                }
            }

            on(eventType, handler) {
                this.eventHandlers[eventType] = handler;
            }
        }

        // Initialize WebSocket client
        let wsClient = new WebSocketClient();

        // Connection setup
        document.getElementById('connectBtn').addEventListener('click', function () {
            const serverIp = document.getElementById('serverIp').value.trim();
            const serverPort = document.getElementById('serverPort').value.trim();

            if (!serverIp || !serverPort) {
                alert('Please enter both server IP and port.');
                return;
            }

            const wsUrl = `ws://${serverIp}:${serverPort}`;
            wsClient.connect(wsUrl).then(() => {
                document.getElementById('connectionStatus').textContent = 'Connected to ' + wsUrl;

                // Request location data periodically
                setInterval(() => {
                    const message = { message_type: 'get_players', arguments: { type: 'location' } };
                    wsClient.sendMessage(message);
                }, 200);
            }).catch((error) => {
                console.error('Connection error:', error);
                document.getElementById('connectionStatus').textContent = 'Connection error';
            });
        });

        // Team color mapping
        const teamColors = {
            '_game_team_red': '#FF4444',
            '_game_team_blue': '#4444FF',
            '_game_team_yellow': '#FFFF44',
            '_game_team_green': '#44FF44',
            '_game_team_purple': '#AA44AA',
            '_game_team_orange': '#FF8844',
            '_game_team_brown': '#8B4513',
            '_game_team_pink': '#FF69B4',
            '_game_team_neutral': '#AAAAAA'
        };

        // Height difference threshold for showing arrows
        // Player model is ~2 units tall, 150% = 3 units difference triggers arrow
        const heightThreshold = 3.0;
        const symbolSize = 8;
        const facingArrowLength = 15; // Length of facing direction arrow

        // Function to draw the minimap
        function drawMinimap() {
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Get first player's Z as reference (or use 0)
            let referenceZ = 0;
            const playerNames = Object.keys(playersData);
            if (playerNames.length > 0) {
                referenceZ = playersData[playerNames[0]].Z || 0;
            }

            // Loop through each player in playersData
            for (const playerName in playersData) {
                const player = playersData[playerName];
                const x = player.X; // X coordinate in world units
                const y = player.Y; // Y coordinate in world units
                const z = player.Z; // Z coordinate in world units
                const facing = player.facing || 0; // Facing angle in radians
                const team = player.team || '_game_team_neutral';

                // Convert world coordinates to canvas coordinates
                const canvasX = halfCanvasSize + x * scale;
                const canvasY = halfCanvasSize - y * scale;

                // Get team color
                const color = teamColors[team] || '#FFFFFF';

                // Determine height difference from reference player
                const heightDiff = z - referenceZ;

                ctx.fillStyle = color;
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 1;

                if (heightDiff > heightThreshold) {
                    // Player is higher - draw up arrow
                    ctx.beginPath();
                    ctx.moveTo(canvasX, canvasY - symbolSize);
                    ctx.lineTo(canvasX + symbolSize, canvasY + symbolSize);
                    ctx.lineTo(canvasX - symbolSize, canvasY + symbolSize);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else if (heightDiff < -heightThreshold) {
                    // Player is lower - draw down arrow
                    ctx.beginPath();
                    ctx.moveTo(canvasX, canvasY + symbolSize);
                    ctx.lineTo(canvasX + symbolSize, canvasY - symbolSize);
                    ctx.lineTo(canvasX - symbolSize, canvasY - symbolSize);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else {
                    // Player is at similar height - draw circle
                    ctx.beginPath();
                    ctx.arc(canvasX, canvasY, symbolSize, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }

                // Draw facing direction arrow
                // facing is yaw from atan2(Y, X) in world coords
                // Canvas Y is inverted, so we negate the Y component
                const arrowEndX = canvasX + Math.cos(facing) * facingArrowLength;
                const arrowEndY = canvasY - Math.sin(facing) * facingArrowLength; // Negate for canvas coords

                // Draw arrow line
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(canvasX, canvasY);
                ctx.lineTo(arrowEndX, arrowEndY);
                ctx.stroke();

                // Draw arrowhead
                const arrowHeadSize = 5;
                const arrowAngle = Math.atan2(canvasY - arrowEndY, canvasX - arrowEndX);
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(arrowEndX, arrowEndY);
                ctx.lineTo(
                    arrowEndX + arrowHeadSize * Math.cos(arrowAngle - Math.PI / 6),
                    arrowEndY + arrowHeadSize * Math.sin(arrowAngle - Math.PI / 6)
                );
                ctx.lineTo(
                    arrowEndX + arrowHeadSize * Math.cos(arrowAngle + Math.PI / 6),
                    arrowEndY + arrowHeadSize * Math.sin(arrowAngle + Math.PI / 6)
                );
                ctx.closePath();
                ctx.fill();

                // Draw player name above the symbol
                ctx.fillStyle = '#FFFFFF';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.strokeText(playerName, canvasX, canvasY - symbolSize - 2);
                ctx.fillText(playerName, canvasX, canvasY - symbolSize - 2);
            }
        }
    </script>
</body>
</html>